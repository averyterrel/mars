// types

    i8
    i16
    i32
    i64
    int :: i64

    u8
    u16
    u32
    u64
    uint :: u64

    b8
    b16
    b32
    b64
    bool :: b64

    f16
    f32
    f64
    float :: f64

    (untyped_integer) -> int
    (untyped_float)   -> float
    (untyped_string)  -> []u8

    ^T // pointer to type T, u64 under the hood

    rawptr // raw pointer with no type information

    // array of type T
    []T :: struct {
        _ : ^T,  // base
        _ : u64, // length
    }

    struct // c-like structs - members are aligned to size-alignment boundaries

    union // c-like unions - members are aligned to largest member's alignment

    enum // c-like enums - default representation is int but can be specified (must be integer type though)

    fn(_: X, _: Y) -> (_: Z, _: W) // function type determined by input param types and return param types (no information is kept at runtime, internally a rawptr)

// declarations

    // constant declaration - constant at compile time
    a : int : 0 // explicit type
    a :     : 0 // implicit type
    a :: 0 // same as above

    // variable declaration
    b : int = 0 // explicit type
    b :     = 0 // implicit type
    b := 0 // same as above

    c : []int = []int{0, 1, 2}
    c := []int{0, 1, 2}
    c : []int = {0, 1, 2}
    c := {0, 1, 2} // compiler will attempt to figure out what type array this is based on the untyped_string

    d := "string" // string literal gets converted to []u8 literal with utf8 encoding

    arr := []int{0,3,0}