types
    signed integer
        i8
        i16
        i32
        i64
        int :: i64

    unsigned integer
        u8
        u16
        u32
        u64
        uint :: u64

    boolean
        b8
        b16
        b32
        b64
        bool :: b64

    floating point
        f16
        f32
        f64
        float :: f64

    pointer
        ^T              pointer to type T. distinct uint
        rawptr          pointer with no type information. distinct uint
        fn() -> ()      pointer to function. distinct uint.

    enum
        enum T          enumeration over type T (default: int). T must be in (all integers, uintegers)

    untyped/literal
        (untyped_int)   internal int literal - can implicitly convert to any numeric type (if in range)
        (untyped_float) internal float literal - can implictly convert to any float type, or an int type if it represents an integer value (12.0 for example)
        (untyped_bool)  internal bool literal - can implicitly convert to any boolean type
        (untyped_null)  internal "null" literal - implicitly converts to any pointer

    compound
        [?]T            concrete array type with determined length at compile time
        []T             slice defined as hidden struct {base: ^T, len: int}
        struct          data structure
        union           sum type

operators
    unary numeric
        -       negation (0 - x)        with type T in (all integers, uintegers, floats, pointers): - T -> T
        ~       bitwise complement      with type T in (all integers, uintegers, floats, pointers): ~ T -> T

    unary boolean
        !       boolean not             with type T in (all booleans): !T -> T

    binary numeric
        +       addition                with type T in (all integers, uintegers, floats, pointers): T + T -> T
        -       subtraction             with type T in (all integers, uintegers, floats, pointers): T - T -> T
        *       multiplication          with type T in (all integers, uintegers, floats, pointers): T * T -> T
        /       division                with type T in (all integers, uintegers, floats, pointers): T / T -> T
        %       modulo (truncated)      with type T in (all integers, uintegers, pointers): T % T -> T
        %%      remainder (floored)     with type T in (all integers, uintegers, pointers): T %% T -> T

    binary logical
        &       bitwise and             with type T in (all integers, uintegers, floats, pointers): T ~ T -> T
        |       bitwise or              with type T in (all integers, uintegers, floats, pointers): T ~ T -> T
        ~|      bitwise nor             with type T in (all integers, uintegers, floats, pointers): T ~ T -> T
        ~       bitwise xor             with type T in (all integers, uintegers, floats, pointers): T ~ T -> T
        <<      left shift              with type T in (all integers, uintegers, floats, pointers): T << (all uintegers) -> T
        >>      right shift             with type T in (all integers, uintegers, floats, pointers): T >> (all uintegers) -> T

    binary boolean
        &&      boolean and             with type T in (all booleans): T && T -> T
        ||      boolean or              with type T in (all booleans): T || T -> T
        ~~      boolean xor             with type T in (all booleans): T ~~ T -> T

    comparison
        ==      equality                (*): T == T -> bool
        !=      inequality              (*): T != T -> bool
        <       less than               (**): T < T -> bool
        <=      less than or equal      (**): T <= T -> bool
        >       greater than            (**): T > T -> bool
        >=      greater than or equal   (**): T >= T -> bool

        * a type T is comparable if it is a:
        | base, non-compound type (all integers, uintegers, floats, booleans, pointers)
        | struct with comparable fields
        | union with comparable variants
        | array with comparable element type
        | slice with comparable element type
        | enum with a numeric backing type

        ** a type is orderable if it is a:
        | numeric type (all integers, uintegers, floats, pointers)
        | enum with a numeric backing type

    unary conversion
        cast(T)     value cast to type T        (*): cast(T) X -> T
        bitcast(T)  raw data cast to type T     (**): bitcast(T) X -> T

        * type casting rules:
        | all types can cast to themselves. this should not generate code.
        | all (u)integer types can cast between each other.
        |       if one is casting to another of smaller size, the most-significant "top" bits are discarded
        |       casts between (u)integers of the same size behave the same as bitcasts
        | all boolean types can cast between each other
        | all pointer types can cast between each other
        | all pointer types can cast to u64/uint
        | all (u)integer types can cast to floating point types, converting to their closest floating point representation
        | all floating point types can cast to (u)integer types, truncating and mapping to their closest representation
        | enums have the same casting characteristics of its backing type
        | structs may be cast to other structs if their field structure is identical (all fields in the same order with the same types)

        ** values can be bitcast if their byte sizes are the same
        | bitcasting does not modify the value data of a variable,
        | but only changes what datatype the value is interpreted as
        | because of this, bitcasting as an operation does not produce code
    
    unary reference
        &       generate pointer        with type T in (all): &T -> ^T
        $       dereference pointer     with type T in (all): (^T)^ -> T


    precendence
        unary operators have highest precedence.

        binary operator precedence:
        5   *   /   %   %%   &   <<   >>  ~|
        4   +   -   |   ~
        3   ==  !=  <   >    <=  >=
        2   &&
        1   ||

        operators of the same precedence are evaluated left-to-right.
        ex. a * b / c == (a * b) / c

    compound assignment
        +=      addition                (variable of type T) T += T
        -=      subtraction             (variable of type T) T -= T
        *=      multiplication          (variable of type T) T *= T
        /=      division                (variable of type T) T /= T
        %=      modulo (truncated)      (variable of type T) T %= T
        %%=     remainder (floored)     (variable of type T) T %%= T
        &=      bitwise and             (variable of type T) T &= T
        |=      bitwise or              (variable of type T) T |= T
        ~|=     bitwise nor             (variable of type T) T ~|= T
        ~=      bitwise xor             (variable of type T) T ~= T
        <<=     left shift              (variable of type T) T <<= (all uintegers)
        >>=     right shift             (variable of type T) T >>= (all uintegers)

program structure