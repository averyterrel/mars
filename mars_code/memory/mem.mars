module memory;

copy :: fn(to, from: addr, len: uint) {
    
    to_byte   : ^u8 = to;
    from_byte : ^u8 = from;
    to_stop   := to_byte + cast(^u8) len

    while to_byte != to_stop {

        $to_byte = $from_byte;

        from_byte += 1;
        to_byte += 1;
    }
}

equal :: fn(block1, block2: addr, len: uint) -> bool {

    block1_byte := cast(^u8) block1;
    block2_byte := cast(^u8) block2;
    block1_stop := block1_byte + cast(^u8) len;

    while block1_byte != block1_stop {

        if $block1_byte != $block2_byte {
            return false;
        }

        block1_byte += 1;
        block2_byte += 1;
    }

    return true;
}

set :: fn(dest: addr, len: uint, val: u8) {

    cursor := cast(^u8) dest;
    stop   := cursor + cast(^u8) len;

    while cursor != stop {
        $cursor = val;
        cursor += 1;
    }
}

slice_equal :: fn(a, b: []u8) -> bool {

    // trivial cases
    if a.len != b.len { return false; }
    
    return equal(a.base, b.base, a.len);
}